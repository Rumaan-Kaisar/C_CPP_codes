/* 
    --------------|    POINTERS WITH ARRAYS    |--------------
    In C, pointers and arrays are closely related. In fact, they are often interchangeable.
    It is the most important feature of C.
        using an array name 'without an index', you are generating a pointer to the start of the array.
        a pointer is being passed to gets() is not an array
        gets() uses the pointer to load the array it points to with the characters you enter at the keyboard
        
        We'll see how this is done later.

        assign a value to another pointer and access the array using pointer arithmetic.



    --------------|    TO ACCESS MULTIDIMENSIONAL ARRAYS    |--------------
    To use a pointer to access multidimensional arrays, you must manually do what the compiler does automatically.
        For example, in this array:
            float balance[10][5];
        each row is five elements long. Therefore, to access balance[3][1] using a pointer you must use a fragment like this:

            float *p;
            p = (float *) balance; 	//assigning the balance array to p with type cast 
            printf("%d", *(p + (3*5) + 1); 	// accessing balance[3][1]

        Here we converted the two dimensional array to an one dimensional array. 
        If we look closely we see that the position of an element in an array is :  (position_row - 1)×Totalcolumn + postion_column    
            for example position of a[i][j] element of m×n 2-D array is (i-1)n+j or n(i-1)+j. 
            Hence the position of balance[3][1] is (4-1)5+2=3*5+1=16 (we used 4 and 1 because array in C starts from 0, 16 means the 17-th element). 
            Again, we know that to point k-th element of an one-dimensional array by a pointer p we use *(p+(k-1)), hence  *(p+(3*5)+1) since k=(3*5)+2.

        Note: to access a[i][j]of a[m][n] ∶  i*n+j; element in a row=n. 
        Generally, with multidimensional arrays it is easier to use array indexing rather than pointer arithmetic.

        The cast of balance to (float *) was necessary. Since the array is being indexed manually, 
            the pointer arithmetic must be relative to a float pointer (to access the location of float type values ). 
            However, the type of pointer generated by balance is to a two-dimensional array of floats. Thus, there is need for the cast.
*/  


/* Example 1: you can assign that value to another pointer and access the array using pointer arithmetic. Consider this program: */
// The parentheses *(p+2) are necessary because the * has a higher precedence than the + operator.
#include <stdio.h>

int main(void){	
    int a[10] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
    int *p;

    p = a; 	// assign p the address of start of a
    
    // following prints a's first, second and third elements
    printf("%d %d %d\n", *p, *(p+1), *(p+2));

    // following does the same thing using a
    printf ( "%d %d %d", a[0], a[1], a[2]);

    return 0;
}




/* 
    --------------|    USING A POINTER WITH ARRAY    |--------------
    Notes
        You should index a pointer only when that pointer points to an array. 
        Following fragment is syntactically correct, It is wrong; It can crash your computer.
        
        char *p, ch;  
        int i;

        p = &ch;

        for(i=0; i<10; i++) p[i] = 'A'+i; // wrong 

        Since ch is not an array, it cannot be meaningfully indexed. 
*/

/* Example 2: Using a pointer with array. We can index a pointer as if  it were an array. 
                The following program, following example, is perfectly valid: */
#include <stdio.h>
int main(void){ 	
    char str[] = "Pointers are fun";
    char *p;
    int i;

    // since an array name 'without an index' is a pointer we dont need '&'
    p = str; // Assigning pointer to string

    // loop until null is found i.e. untill p[i]=0
    for(i=0; p[i]; i++) printf("%c", p[i]);	 // using pointer as string

    return 0;
}




/* Example 3: Because an array name without an index is a pointer to the start of the array,
                use pointer arithmetic rather than array indexing to access elements of the array. 
                Pointer arithmetic is usually more convenient. 
                    Also, in some cases a C compiler can generate faster executable code for an expression involving pointers.
                */

#include <stdio.h>
int main(void) {
    char str[80];

    *(str+3) = 'c';
    printf("%c", *(str+3));
    
    return 0;
}

/* You cannot, however, 'modify the value' of the "pointer generated by using an array name". 
For example, assuming the previous program, this is an invalid statement:  
    str++; */




/* Example 4: Lowercase-Uppercase transform function with CTYPE.H header : 
                Two of C's library functions, toupper() and tolower(), are cal1ed using a "character argument".  These functions use the header file CTYPE.H.
	            This version uses 'array indexing' to access the characters in the string so they can be converted into the appropriate case. */

#include <stdio.h>
#include <ctype.h>

int main (void){
    char str[80];
    int i;

    printf("Enter a string:");
    gets(str);

    for(i=0; str[i]; i++) str[i] = toupper(str[i]);
    printf("%s\n", str);    // uppercase string

    for(i=0; str[i]; i++) str[i] = tolower(str[i]);
    printf("%s\n", str);    // lowercase string

    return 0;
}


/*      The same program is shown below, only this time, a pointer is used to access the string. 
        professional C programmers uses this approach because incrementing a pointer is often faster than indexing an array. 
        
        Note:  while working with array, *p is the value stored at the location p. 
                Do not get confused because "&" is not used.
 */

#include <stdio.h>
#include <ctype.h>
int main (void){
    char str[80], *p;
    int i;

    printf("Enter a string:");
    gets(str);
    
    p=str;
    while(*p){
        *p = toupper(*p);
        p++;
    }
    printf("%s\n",str); //upercase
    
    p=str;
    while(*p){
        *p = tolower(*p);
        p++;
    }
    printf("%s\n",str); //lowercase
    
    return 0; 
}

/* 
    while(*p){
        *p = tolower(*p);
        p++;
    }

    generally written as:
        while(*p) *p++ = tolower(*p);

    the ++ follows the p, the value pointed to by p is first
    modified and then p is incremented to point to the next element
*/




/* Example 5: you can decrement a pointer as well. For example, the following program uses a pointer to copy the
                contents of one string into another in reversed order */
#include <stdio.h>
#include <string.h>

int main(void){
    char str1[] = "Pointers are fun to use";
    char str2[80], *p1, *p2;
    
    // make p to point to the end of str1
    p1 = str1 + strlen(str1) - 1;
    
    p2=str2;
    
    while(p1 >= str1) *p2++ = *p1--;
    
    // null terminate str2
    *p2='\0';
    
    printf("%s %s",str1,str2);
    return 0;

}
/* 
    while(p1 >= str1) *p2++ = *p1--;
    can be written as
    while(p1 >= str1){
        *p2 = *p1;
        *p2++;
        *p1--;
    } 

 */



/* Example 6: Is this fragment correct?
    int count [10];
    . . .
    . . .
    count = count + 2;

    Ans: No, you "cannot change the value" of a pointer that is generated by using an array name without an "index".
 */




/* Example 7: What value does this fragment display?
                int temp[5] = {10, 19, 23, 8, 9};
                int *P;

                p = temp;
                printf("%d", *(p+ 3)); 
            
                Ans: 4th element 8.
*/




/* Example 8: Write a program that inputs a string. Have the program look for
                the first space. If it finds one, print the remainder of the string */

#include <stdio.h>
#include <string.h>

int main(void){
    char str[80], *p;
    
    printf("Enter a string:");
    gets(str);
    
    p=str;

    /* While not at the end of the string and no space has been enc0untered, 
    increment p to point to next character  */
    while(*p && (*p != ' ')) p++;

    printf(p);

    return 0;
}



