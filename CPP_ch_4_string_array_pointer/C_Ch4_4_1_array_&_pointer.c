
/* 
    --------------|    POINTERS WITH ARRAYS    |--------------
    In C, pointers and arrays are closely related. In fact, they are often interchangeable.
    It is the most important feature of C.
        using an array name 'without an index', you are generating a pointer to the start of the array.
        a pointer is being passed to gets() is not an array
        gets() uses the pointer to load the array it points to with the characters you enter at the keyboard
        
        We'll see how this is done later.

        assign a value to another pointer and access the array using pointer arithmetic.



    --------------|    TO ACCESS MULTIDIMENSIONAL ARRAYS    |--------------
    To use a pointer to access multidimensional arrays, you must manually do what the compiler does automatically.
        For example, in this array:
            float balance[10][5];
        each row is five elements long. Therefore, to access balance[3][1] using a pointer you must use a fragment like this:

            float *p;
            p = (float *) balance; 	//assigning the balance array to p with type cast 
            printf("%d", *(p + (3*5) + 1); 	// accessing balance[3][1]

        Here we converted the two dimensional array to an one dimensional array. 
        If we look closely we see that the position of an element in an array is :  (position_row - 1)×Totalcolumn + postion_column    
            for example position of a[i][j] element of m×n 2-D array is (i-1)n+j or n(i-1)+j. 
            Hence the position of balance[3][1] is (4-1)5+2=3*5+1=16 (we used 4 and 1 because array in C starts from 0, 16 means the 17-th element). 
            Again, we know that to point k-th element of an one-dimensional array by a pointer p we use *(p+(k-1)), hence  *(p+(3*5)+1) since k=(3*5)+2.

        Note: to access a[i][j]of a[m][n] ∶  i*n+j; element in a row=n. 
        Generally, with multidimensional arrays it is easier to use array indexing rather than pointer arithmetic.

        The cast of balance to (float *) was necessary. Since the array is being indexed manually, 
            the pointer arithmetic must be relative to a float pointer (to access the location of float type values ). 
            However, the type of pointer generated by balance is to a two-dimensional array of floats. Thus, there is need for the cast.
*/  


/* Example 1: you can assign that value to another pointer and access the array using pointer arithmetic. Consider this program: */
// The parentheses *(p+2) are necessary because the * has a higher precedence than the + operator.
#include <stdio.h>

int main(void){	
    int a[10] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
    int *p;

    p = a; 	// assign p the address of start of a
    
    // following prints a's first, second and third elements
    printf("%d %d %d\n", *p, *(p+1), *(p+2));

    // following does the same thing using a
    printf ( "%d %d %d", a[0], a[1], a[2]);

    return 0;
}




/* 
    --------------|    USING A POINTER WITH ARRAY    |--------------
    Notes
        You should index a pointer only when that pointer points to an array. 
        Following fragment is syntactically correct, It is wrong; It can crash your computer.
        
        char *p, ch;  
        int i;

        p = &ch;

        for(i=0; i<10; i++) p[i] = 'A'+i; // wrong 

        Since ch is not an array, it cannot be meaningfully indexed. 
*/

/* Example 2: Using a pointer with array. We can index a pointer as if  it were an array. 
                The following program, following example, is perfectly valid: */
#include <stdio.h>
int main(void){ 	
    char str[] = "Pointers are fun";
    char *p;
    int i;

    // since an array name 'without an index' is a pointer we dont need '&'
    p = str; // Assigning pointer to string

    // loop until null is found i.e. untill p[i]=0
    for(i=0; p[i]; i++) printf("%c", p[i]);	 // using pointer as string

    return 0;
}




/* Example 3: Because an array name without an index is a pointer to the start of the array,
                use pointer arithmetic rather than array indexing to access elements of the array. 
                Pointer arithmetic is usually more convenient. 
                    Also, in some cases a C compiler can generate faster executable code for an expression involving pointers.
                */

#include <stdio.h>
int main(void) {
    char str[80];

    *(str+3) = 'c';
    printf("%c", *(str+3));
    
    return 0;
}

/* You cannot, however, 'modify the value' of the "pointer generated by using an array name". 
For example, assuming the previous program, this is an invalid statement:  
    str++; */
